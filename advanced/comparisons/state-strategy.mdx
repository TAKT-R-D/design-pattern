# ğŸ” State vs Strategy

## âœ… Purpose of Comparison

The `State` and `Strategy` patterns both aim to **enable interchangeable behaviors**, but they serve **different design purposes**. This comparison clarifies when to use each pattern by examining their intent, structure, and usage in practice.

## âœ… Comparison Overview

| Aspect              | State                                   | Strategy                               |
| ------------------- | --------------------------------------- | -------------------------------------- |
| Primary Purpose     | Switch behavior based on internal state | Switch behavior via external strategy  |
| Structure           | Delegates to state-specific classes     | Delegates to strategy-specific classes |
| Trigger for Change  | Internal state transitions              | External configuration or injection    |
| Switching Mechanism | Object manages its own state transition | Client selects and injects strategy    |
| State Management    | Maintains current state                 | Stateless, focuses on algorithms       |

## âœ… Similarities

- Both patterns support **behavioral flexibility** without complex conditionals.
- Behavior is delegated via **shared interfaces**, improving extensibility.
- Used to **encapsulate variant logic** and reduce code duplication.

## âœ… Key Differences

| Perspective       | State Pattern                               | Strategy Pattern                        |
| ----------------- | ------------------------------------------- | --------------------------------------- |
| Ownership         | Controlled by the objectâ€™s internal logic   | Controlled by the external caller       |
| Dynamic Switching | State transitions happen within the object  | Strategy changes happen externally      |
| Concept of State  | Explicit stateful behavior with transitions | Stateless, context-independent behavior |
| Client Role       | Unaware of internal state handling          | Responsible for selecting strategy      |

## âœ… When to Choose Which

- âœ… Use **State** when behavior depends on the **object's internal condition**
- âœ… Use **Strategy** when you need to **switch algorithms or policies externally**
- âœ… Choose **State** when transitions happen as part of object workflow
- âœ… Choose **Strategy** when you need configurable or testable behaviors

## âœ… UML Class Diagram

### State Pattern

```mermaid
classDiagram
  class Context {
    -state: State
    +request()
    +setState(state)
  }

  class State {
    +handle(context)
  }

  class StateA {
    +handle(context)
  }

  class StateB {
    +handle(context)
  }

  Context --> State
  State <|-- StateA
  State <|-- StateB
```

### Strategy Pattern

```mermaid
classDiagram
  class Context {
    -strategy: Strategy
    +execute()
    +setStrategy(strategy)
  }

  class Strategy {
    +execute()
  }

  class StrategyA {
    +execute()
  }

  class StrategyB {
    +execute()
  }

  Context --> Strategy
  Strategy <|-- StrategyA
  Strategy <|-- StrategyB
```

## âœ… Practical Design Notes

- âœ… **Use State** when implementing domain logic that changes over time (e.g., login status, order phases).
- âœ… **Use Strategy** when separating interchangeable policies or behaviors (e.g., notification methods, authentication).
- â–¶ï¸ These patterns are often confusedâ€”understand **who initiates the change** and **where state is stored**.

## âœ… Summary

- `State` encapsulates behavior changes **based on internal transitions**.
- `Strategy` encapsulates **interchangeable behaviors** selected externally.
- While structurally similar, they differ in **control flow and behavioral ownership**.
- Choosing the correct pattern depends on whether flexibility is required in **internal evolution** or **external configuration**.
