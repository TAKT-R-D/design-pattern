# まとめ

## パターン比較レビュー

| パターン                  | 適用条件                 | 強み                     | 注意点                   | よく使うシーン                       |
| ------------------------- | ------------------------ | ------------------------ | ------------------------ | ------------------------------------ |
| `Strategy`                | 条件による処理分岐       | 柔軟性・テスト性が高い   | 実装クラスが増えがち     | 割引処理、計算方式切替               |
| `State`                   | 状態遷移がある           | 状態管理が明確           | 状態が少ないと過剰設計   | UI モード、業務フロー                |
| `Command`                 | 操作履歴が必要           | Undo/Redo にも対応       | 命令オブジェクトが増える | テキストエディタ、操作記録           |
| `Chain of Responsibility` | 処理の流れが一定         | 責務の分離と拡張性 ◎     | 処理漏れに注意           | バリデーション、ミドルウェア処理など |
| `Interpreter`             | ルール・条件が複雑で可変 | 条件ロジックの外部定義化 | 実装が複雑化しやすい     | ルールエンジン、DSL、検索式          |

## まとめと選び方の指針

- 単純な条件切り替え → `Strategy`
- 状態の変化を伴う場合 → `State`
- 処理そのものを抽象化して再利用 → `Command`
- 連続的に処理を試したい → `Chain of Responsibility`
- 条件を柔軟に追加・定義したいなら `Interpreter` を検討

## 実際の設計会話での使い分けヒント

- この条件分岐、`Strategy` に切り出せばテストもしやすくなりますね
- 状態管理なら `State` に分けた方が流れが明確になります
- 似た処理が並んでるなら `Command` にして履歴も取れます
- この条件分岐、チェーンで順に試していく方が自然じゃないですか？
- フローが決まってるなら `Chain of Responsibility` で順番に任せましょう
- この if ツリー、ルールとして宣言できるなら `Interpreter` 化して DSL 的に評価できますよ
