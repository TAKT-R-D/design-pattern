# 🧩 Event Loop ベース構造

## ✅ このスタイルの概要

**1 本（または少数）のイベントループが、非同期 I/O とコールバック／ハンドラを順に処理していく構造スタイル。**  
Node.js やブラウザの JavaScript 実行環境などで代表的。

## ✅ 解決しようとした問題

- リクエストごとにスレッドを立てる同期 I/O モデルのスケーラビリティ限界
- スレッドコンテキストスイッチやロックコスト
- 大量接続（C10K 問題など）への対応

Event Loop モデルは、

> 「スレッドを増やす代わりに、  
>  非同期 I/O とイベントループで多くの接続をさばく」

ことで、高スループットを実現する。

## ✅ 基本思想・ルール

### ● Event Loop

- イベントキューからイベントを 1 つずつ取り出し、  
  対応するハンドラを実行するループ

### ● 非同期 I/O

- I/O 操作（ネットワーク、ファイルなど）は非同期で発行
- 完了時にイベントがキューに積まれ、次のループで処理される

### ● 単一スレッドモデル（のことが多い）

- ロックや共有メモリを極力使わない設計
- 代わりにコールバック／Promise／async/await などで非同期を表現

## ✅ 得意なアプリケーション

- 多数のクライアント接続を扱う Web サーバ
- チャット・ゲーム・リアルタイム Web アプリ
- 軽量な API サーバ

特徴：

- I/O バウンドな処理に強い
- メモリ消費が少なく、少ないスレッドでスケールしやすい

## ❌ 不向きなケース

- CPU バウンドな重い計算を多く含むアプリ
- 長時間ブロッキングする処理（ループを塞いでしまう）

こうした処理は、ワーカー（別スレッド／プロセス）に逃がす必要がある。

## ✅ 歴史（系譜・親スタイル）

- GUI イベントループ（メインスレッド）からの発展
- 非同期 I/O モデル（epoll, kqueue 等）と組み合わせてサーバサイドへ
- Node.js をはじめとするイベント駆動サーバプラットフォームで広く普及

## ✅ 関連スタイル

- **[Actor Model](./actor-model.md)**：メッセージ駆動だが、実装に Event Loop を利用することも多い
- **[Reactive Streams](./reactive-streams.md)**：イベントストリーム処理の抽象化
- **[EDA](../../integration/event-driven.md) / Pub-Sub**：システム全体でのイベント駆動構造

## 8. 代表的なフレームワーク

Event Loop ベース構造は、非同期 I/O を中心としたプラットフォームで広く採用されている。

- **Node.js**  
  もっとも代表的な Event Loop 実装。単一スレッド＋非同期 I/O のモデルが中核。

- **ブラウザ（JavaScript ランタイム）**  
  `setTimeout` / `Promise` / `fetch` などはすべて Event Loop の上で動作。

- **Deno / Bun（JavaScript ランタイム）**  
  Node.js と同様のイベントループモデルを採用。

- **Nginx / Envoy などの高性能サーバ**  
  コア内部でイベントループ＋非同期 I/O による高スループットを実現。

## 9. このスタイルを支えるデザインパターン

Event Loop 自体は低レイヤの実行モデルだが、次のパターンと強く結びつく。

- **Observer**  
  イベント発火 → ハンドラの実行という通知モデルの基本。

- **Command**  
  非同期コールバックや処理を“操作オブジェクト”として扱う場面で利用。

- **Mediator**  
  複数のイベント／ハンドラを調整する仕組みとして使われることがある。

- **Iterator**  
  非同期ストリームを逐次処理する際に役立つ（AsyncIterator など）。

## ✅ まとめ

Event Loop ベース構造は、

- 非同期 I/O
- イベントキュー
- 単一（または少数）のループ

というシンプルな考え方で高スループットを実現するスタイルである。

I/O バウンドなサーバを設計するときの、  
**“デフォルト候補” の一つとして検討するとよい。**
