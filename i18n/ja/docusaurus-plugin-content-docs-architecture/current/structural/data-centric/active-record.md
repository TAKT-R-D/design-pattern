# 🧩 Active Record

## ✅ このスタイルの概要

**「1 テーブル = 1 クラス、1 行 = 1 インスタンス」**  
という極めて直感的で実装しやすい**データ中心スタイル**。  
データベース構造をアプリケーションのモデルとしてそのまま利用する。

## ✅ 解決しようとした問題

Active Record が解決したかったのは、主に次のような実務的課題。

- O/R マッピング（テーブル ⇄ オブジェクト）の手間を減らしたい
- CRUD の典型的なパターンを自動化／抽象化したい
- モデルクラスのメソッドとしてデータ操作できるようにしたい
- フレームワークを使って高速に開発したい

特に Rails における ActiveRecord の成功によって、  
**高速開発のデファクトスタンダード** になった。

## ✅ 基本思想・ルール

### ● テーブルとクラスの 1:1 対応

- クラス名 → テーブル名
- プロパティ → カラム
- インスタンス → 行

### ● 行単位の操作（インスタンスメソッド）

- `save`
- `update`
- `destroy`

### ● 集合単位の操作（クラスメソッド）

- `find`
- `where`
- `order`

### ● 軽量なビジネスロジックの集約

- バリデーション
- 簡単な状態チェック
- 単純な条件分岐

**結果として：**  
データ構造・永続化・簡単な振る舞いが **1 クラスに集約** される。

## ✅ 得意なアプリケーション

Active Record が輝くケースは以下のようなシナリオ：

- CRUD 中心のアプリ
- 管理画面
- 管理系ダッシュボード
- 在庫管理など「状態がシンプルな」業務系
- フロントエンドと DB 構造が素直に対応している Web アプリ
- MVP（最小実用プロダクト）

高速性・学習コストの低さは非常に大きな強みである。

## ❌ 不向きなケース

次のようなアプリでは Active Record は破綻しやすい：

- **複雑なビジネスルール**が存在するドメイン
- 1 つのテーブルが複数文脈（コンテキスト）で異なる意味を持つ場合
- 振る舞い（ビジネスロジック）が大量に増えてくる場合
- 外部サービスや複数データソースと連携する複雑なアプリ
- 不変条件・状態遷移を厳密に管理する必要がある場合

→ サービス層やコントローラーにロジックが散乱し、  
**Anemic Domain Model（貧血モデル）** になりがち。

## ✅ 歴史（系譜・親スタイル）

- Fowler の _Patterns of Enterprise Application Architecture_ にてパターン化
- Rails の ActiveRecord 実装により世界的に普及
- Transaction Script スタイルの自然な発展系
- データ中心設計の象徴的存在

## ✅ 関連スタイル

- **[Table Module](./table-module.md)**  
  集合（テーブル全体）に対する操作をまとめるスタイル
- **[Anemic Domain Model](./anemic-domain-model.md)**  
  データ中心スタイルが行き過ぎると発生するアンチパターン
- **[Domain Model](../layered/domain-model-layered.md) / DDD**  
  複雑なドメイン向けの対極的スタイル

## ✅ 代表的なフレームワーク

- **Ruby on Rails（ActiveRecord）**  
  Active Record パターンのもっとも有名な実装。  
  1 クラス＝ 1 テーブル、1 インスタンス＝ 1 行 の思想がそのまま形になる。

- **Laravel（Eloquent ORM）**  
  Rails に近い Active Record 実装。  
  データ中心・高速開発に最適化されており、構造的特徴は Rails と同様。

- **Django（部分的に類似）**  
  Django ORM は Data Mapper 寄りだが、軽量ロジックや簡易 CRUD では  
  Active Record 的な使われ方をすることが多い。

## ✅ このスタイルを支えるデザインパターン

Active Record そのものが Fowler のパターンだが、内部では以下が補助的に利用される。

- **Template Method**  
  永続化処理のステップ（バリデーション → 保存 → コールバック）を統一化する。

- **Strategy**  
  バリデーションや簡易ビジネスルールを差し替える場面で利用される。

- **Proxy**  
  遅延ロード（lazy loading）や関連読み込みに現れる。

- **Observer**  
  モデルの変更時にフック（コールバック）を発火させる仕組み。

- **Command**  
  トランザクションスクリプト的な「単一の操作」を表現する場面で使われる。

## ✅ まとめ

Active Record は次のように評価できる：

- **シンプルな CRUD アプリには非常に生産的で現実的**
- **複雑なドメインにはスケールせず破綻しやすい**

したがって最も重要な問いは：

> このアプリは「Active Record の限界」を超えるほど複雑か？

もし複雑性の兆候が見え始めたら、  
Domain Model・Layered・Hexagonal などへの移行を検討すべきだ。
