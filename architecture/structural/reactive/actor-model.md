# Actor Model

## 1. 一言でいうと

**「アクター」と呼ばれる軽量な並行オブジェクト同士が、  
メッセージの送受信だけでやり取りする並行計算モデル。**

スレッドやロックを直接扱わず、メッセージパッシングで状態をカプセル化する。

---

## 2. 解決しようとした問題

- 共有メモリ＋ロックベース並行処理の複雑さ
- デッドロック／レースコンディションなどの典型的な並行バグ
- 大量のクライアントを扱う高スループットサーバの設計

Actor Model は、

> 「状態をアクターごとに閉じ込め、  
>  共有メモリではなくメッセージでやり取りする」

ことで、並行性を扱いやすくしようとしました。

---

## 3. 基本思想・ルール

### ● Actor（アクター）

- 自身の状態（state）を持つ
- メッセージを受信すると：
  - 状態を更新する
  - 他のアクターにメッセージを送る
  - 新しいアクターを生成する

### ● メッセージパッシング

- アクター間のやり取りはメッセージキューを通じて行われる
- メッセージ送信は非同期
- 共有メモリへの直接アクセスは行わない

### ● スーパービジョン

- 一部の Actor システムでは、親アクターが子アクターの障害を監視し、再起動ポリシーを管理する

---

## 4. 得意なアプリケーション

- 高スループットな分散システム
- チャット／メッセージングサービス
- オンラインゲームサーバ（プレイヤーやルームをアクターとして表現）
- IoT やイベント処理基盤

特徴：

- 並行性をメッセージレベルで制御できる
- 障害時の復旧戦略（スーパービジョン）が明確

---

## 5. 不向きなケース

- 単純な CRUD 中心の Web アプリ
- 並行性の要求が低い業務アプリ

また、アクターモデルに慣れていないチームでは：

- メッセージの設計・フローが複雑化
- デバッグ手法の違いに戸惑う

といった学習コストも発生します。

---

## 6. 歴史（系譜・親スタイル）

- 1970 年代に提案された計算モデルにルーツ
- Erlang / Akka などの実装を通じて実務での採用が進んだ
- Reactive Manifesto やリアクティブシステムの文脈でも重要な位置づけ

---

## 7. 関連スタイル

- **Event Loop ベース構造**：イベントドリブンという点で近いが、モデルは異なる
- **Reactive Streams**：イベントストリーム処理のための標準
- **EDA（Event-Driven Architecture）**：システム全体のイベント駆動構造

---

## 8. Framework Examples（代表的なフレームワーク・実装）

Actor Model は特に並行性が重要な領域で実用実装が多い。

- **Erlang / Elixir（BEAM VM）**  
  軽量プロセス＋メッセージパッシングによる本家の実装。耐障害性に優れる。

- **Akka（Scala / Java）**  
  JVM 上での最も有名な Actor Framework。スーパービジョン、分散、永続化など充実。

- **Orleans（.NET）**  
  “Virtual Actor” モデルを採用し、大規模分散システムで利用される。

- **Ray（Python）**  
  AI / HPC 分野での分散 Actor 実行基盤。タスク・アクターを統一的に扱う。

---

## 9. Supported Design Patterns（このスタイルを支えるデザインパターン）

Actor Model はオブジェクト指向パターンに変換すると、次の要素に該当する。

- **State**  
  アクター内部の状態を外部から隠蔽し、自身のメッセージ処理で更新する。

- **Command**  
  各メッセージを“操作”として扱い、アクターがそれを解釈して実行する。

- **Observer**  
  イベント駆動でメッセージを受け取り、次の処理をトリガーする。

- **Mediator**  
  メッセージルーティングやアクター同士の連携を調整する際に現れる。

---

## 8. まとめ

Actor Model は、

- 並行性
- メッセージパッシング
- 障害分離

を強く意識した構造スタイルです。

スレッドやロックを直接扱う代わりに、  
**「アクターとメッセージ」という単位でシステムを設計する** 発想が特徴的です。
